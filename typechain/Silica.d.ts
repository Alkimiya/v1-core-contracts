/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface SilicaInterface extends ethers.utils.Interface {
  functions: {
    "allowance(address,address)": FunctionFragment;
    "amountDueAtContractEnd()": FunctionFragment;
    "amountLocked()": FunctionFragment;
    "amountOwedNextUpdate()": FunctionFragment;
    "approve(address,uint256)": FunctionFragment;
    "balanceOf(address)": FunctionFragment;
    "buyerRedeem()": FunctionFragment;
    "buyerRedeemDefault()": FunctionFragment;
    "calculateHaircut(uint256)": FunctionFragment;
    "contractPeriod()": FunctionFragment;
    "decimals()": FunctionFragment;
    "decreaseAllowance(address,uint256)": FunctionFragment;
    "defaultContract(uint32,uint256,uint256)": FunctionFragment;
    "deployTime()": FunctionFragment;
    "deposit(uint256)": FunctionFragment;
    "endDay()": FunctionFragment;
    "fulfillUpdate(uint256,uint256)": FunctionFragment;
    "hashrate()": FunctionFragment;
    "increaseAllowance(address,uint256)": FunctionFragment;
    "initialize(address,uint256,uint256,uint256,address,uint256)": FunctionFragment;
    "isMinerDefaultPayoutComplete()": FunctionFragment;
    "minerRedeem()": FunctionFragment;
    "name()": FunctionFragment;
    "paymentToken()": FunctionFragment;
    "reservedPrice()": FunctionFragment;
    "seller()": FunctionFragment;
    "sellerRedeemDefault()": FunctionFragment;
    "silicaAccount()": FunctionFragment;
    "startDay()": FunctionFragment;
    "status()": FunctionFragment;
    "symbol()": FunctionFragment;
    "totalPayment()": FunctionFragment;
    "totalSold()": FunctionFragment;
    "totalSupply()": FunctionFragment;
    "transfer(address,uint256)": FunctionFragment;
    "transferFrom(address,address,uint256)": FunctionFragment;
    "tryToCompleteContract(uint32,uint256)": FunctionFragment;
    "tryToExpireContract(uint32)": FunctionFragment;
    "tryToStartContract(uint32,uint256,uint256)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "allowance",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "amountDueAtContractEnd",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "amountLocked",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "amountOwedNextUpdate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "balanceOf", values: [string]): string;
  encodeFunctionData(
    functionFragment: "buyerRedeem",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "buyerRedeemDefault",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "calculateHaircut",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "contractPeriod",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "decreaseAllowance",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "defaultContract",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "deployTime",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deposit",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "endDay", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "fulfillUpdate",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "hashrate", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "increaseAllowance",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      string,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isMinerDefaultPayoutComplete",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "minerRedeem",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "paymentToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "reservedPrice",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "seller", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "sellerRedeemDefault",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "silicaAccount",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "startDay", values?: undefined): string;
  encodeFunctionData(functionFragment: "status", values?: undefined): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "totalPayment",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "totalSold", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transfer",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tryToCompleteContract",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tryToExpireContract",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tryToStartContract",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "amountDueAtContractEnd",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "amountLocked",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "amountOwedNextUpdate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "buyerRedeem",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "buyerRedeemDefault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateHaircut",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "contractPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "decreaseAllowance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "defaultContract",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deployTime", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "endDay", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fulfillUpdate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "hashrate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "increaseAllowance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isMinerDefaultPayoutComplete",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "minerRedeem",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "paymentToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reservedPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "seller", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "sellerRedeemDefault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "silicaAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "startDay", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "status", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalPayment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "totalSold", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tryToCompleteContract",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tryToExpireContract",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tryToStartContract",
    data: BytesLike
  ): Result;

  events: {
    "Approval(address,address,uint256)": EventFragment;
    "BidConfirmed(address,uint256,uint256,uint256)": EventFragment;
    "BuyerDefault(address,uint256,uint256)": EventFragment;
    "BuyerRedeem(address,uint256,uint256)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "SellerDefault(address,uint256)": EventFragment;
    "SellerRedeem(address,uint256)": EventFragment;
    "StatusChange(uint256)": EventFragment;
    "Transfer(address,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BidConfirmed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BuyerDefault"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BuyerRedeem"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SellerDefault"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SellerRedeem"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StatusChange"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}

export type ApprovalEvent = TypedEvent<
  [string, string, BigNumber] & {
    owner: string;
    spender: string;
    value: BigNumber;
  }
>;

export type BidConfirmedEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber] & {
    buyer: string;
    purchaseAmount: BigNumber;
    mintedTokens: BigNumber;
    timestamp: BigNumber;
  }
>;

export type BuyerDefaultEvent = TypedEvent<
  [string, BigNumber, BigNumber] & {
    buyer: string;
    paymentAmount: BigNumber;
    rewardAmount: BigNumber;
  }
>;

export type BuyerRedeemEvent = TypedEvent<
  [string, BigNumber, BigNumber] & {
    buyer: string;
    rewardAmount: BigNumber;
    tokensBurned: BigNumber;
  }
>;

export type InitializedEvent = TypedEvent<[number] & { version: number }>;

export type SellerDefaultEvent = TypedEvent<
  [string, BigNumber] & { seller: string; paymentAmount: BigNumber }
>;

export type SellerRedeemEvent = TypedEvent<
  [string, BigNumber] & { seller: string; paymentAmount: BigNumber }
>;

export type StatusChangeEvent = TypedEvent<
  [BigNumber] & { newStatus: BigNumber }
>;

export type TransferEvent = TypedEvent<
  [string, string, BigNumber] & { from: string; to: string; value: BigNumber }
>;

export class Silica extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: SilicaInterface;

  functions: {
    allowance(
      owner: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    amountDueAtContractEnd(overrides?: CallOverrides): Promise<[BigNumber]>;

    amountLocked(overrides?: CallOverrides): Promise<[BigNumber]>;

    amountOwedNextUpdate(overrides?: CallOverrides): Promise<[BigNumber]>;

    approve(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    balanceOf(account: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    buyerRedeem(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    buyerRedeemDefault(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    calculateHaircut(
      day: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    contractPeriod(overrides?: CallOverrides): Promise<[number]>;

    decimals(overrides?: CallOverrides): Promise<[number]>;

    decreaseAllowance(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    defaultContract(
      day: BigNumberish,
      _networkHashrate: BigNumberish,
      _networkReward: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    deployTime(overrides?: CallOverrides): Promise<[number]>;

    deposit(
      purchaseAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    endDay(overrides?: CallOverrides): Promise<[number]>;

    fulfillUpdate(
      _networkHashrate: BigNumberish,
      _networkReward: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    hashrate(overrides?: CallOverrides): Promise<[BigNumber]>;

    increaseAllowance(
      spender: string,
      addedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    initialize(
      _paymentToken: string,
      _hashrate: BigNumberish,
      _contractPeriod: BigNumberish,
      _reservedPrice: BigNumberish,
      _seller: string,
      _amountLockedOnCreate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    isMinerDefaultPayoutComplete(overrides?: CallOverrides): Promise<[boolean]>;

    minerRedeem(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    name(overrides?: CallOverrides): Promise<[string]>;

    paymentToken(overrides?: CallOverrides): Promise<[string]>;

    reservedPrice(overrides?: CallOverrides): Promise<[BigNumber]>;

    seller(overrides?: CallOverrides): Promise<[string]>;

    sellerRedeemDefault(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    silicaAccount(overrides?: CallOverrides): Promise<[string]>;

    startDay(overrides?: CallOverrides): Promise<[number]>;

    status(overrides?: CallOverrides): Promise<[number]>;

    symbol(overrides?: CallOverrides): Promise<[string]>;

    totalPayment(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalSold(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

    transfer(
      to: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    transferFrom(
      from: string,
      to: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    tryToCompleteContract(
      day: BigNumberish,
      remainingExcess: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    tryToExpireContract(
      day: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    tryToStartContract(
      day: BigNumberish,
      _networkHashrate: BigNumberish,
      _networkReward: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  allowance(
    owner: string,
    spender: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  amountDueAtContractEnd(overrides?: CallOverrides): Promise<BigNumber>;

  amountLocked(overrides?: CallOverrides): Promise<BigNumber>;

  amountOwedNextUpdate(overrides?: CallOverrides): Promise<BigNumber>;

  approve(
    spender: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;

  buyerRedeem(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  buyerRedeemDefault(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  calculateHaircut(
    day: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  contractPeriod(overrides?: CallOverrides): Promise<number>;

  decimals(overrides?: CallOverrides): Promise<number>;

  decreaseAllowance(
    spender: string,
    subtractedValue: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  defaultContract(
    day: BigNumberish,
    _networkHashrate: BigNumberish,
    _networkReward: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  deployTime(overrides?: CallOverrides): Promise<number>;

  deposit(
    purchaseAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  endDay(overrides?: CallOverrides): Promise<number>;

  fulfillUpdate(
    _networkHashrate: BigNumberish,
    _networkReward: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  hashrate(overrides?: CallOverrides): Promise<BigNumber>;

  increaseAllowance(
    spender: string,
    addedValue: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  initialize(
    _paymentToken: string,
    _hashrate: BigNumberish,
    _contractPeriod: BigNumberish,
    _reservedPrice: BigNumberish,
    _seller: string,
    _amountLockedOnCreate: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  isMinerDefaultPayoutComplete(overrides?: CallOverrides): Promise<boolean>;

  minerRedeem(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  name(overrides?: CallOverrides): Promise<string>;

  paymentToken(overrides?: CallOverrides): Promise<string>;

  reservedPrice(overrides?: CallOverrides): Promise<BigNumber>;

  seller(overrides?: CallOverrides): Promise<string>;

  sellerRedeemDefault(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  silicaAccount(overrides?: CallOverrides): Promise<string>;

  startDay(overrides?: CallOverrides): Promise<number>;

  status(overrides?: CallOverrides): Promise<number>;

  symbol(overrides?: CallOverrides): Promise<string>;

  totalPayment(overrides?: CallOverrides): Promise<BigNumber>;

  totalSold(overrides?: CallOverrides): Promise<BigNumber>;

  totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

  transfer(
    to: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  transferFrom(
    from: string,
    to: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  tryToCompleteContract(
    day: BigNumberish,
    remainingExcess: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  tryToExpireContract(
    day: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  tryToStartContract(
    day: BigNumberish,
    _networkHashrate: BigNumberish,
    _networkReward: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    allowance(
      owner: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    amountDueAtContractEnd(overrides?: CallOverrides): Promise<BigNumber>;

    amountLocked(overrides?: CallOverrides): Promise<BigNumber>;

    amountOwedNextUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    approve(
      spender: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    buyerRedeem(overrides?: CallOverrides): Promise<BigNumber>;

    buyerRedeemDefault(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        tokensBurned: BigNumber;
        redeemedAmount: BigNumber;
      }
    >;

    calculateHaircut(
      day: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    contractPeriod(overrides?: CallOverrides): Promise<number>;

    decimals(overrides?: CallOverrides): Promise<number>;

    decreaseAllowance(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    defaultContract(
      day: BigNumberish,
      _networkHashrate: BigNumberish,
      _networkReward: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    deployTime(overrides?: CallOverrides): Promise<number>;

    deposit(
      purchaseAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    endDay(overrides?: CallOverrides): Promise<number>;

    fulfillUpdate(
      _networkHashrate: BigNumberish,
      _networkReward: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hashrate(overrides?: CallOverrides): Promise<BigNumber>;

    increaseAllowance(
      spender: string,
      addedValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    initialize(
      _paymentToken: string,
      _hashrate: BigNumberish,
      _contractPeriod: BigNumberish,
      _reservedPrice: BigNumberish,
      _seller: string,
      _amountLockedOnCreate: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    isMinerDefaultPayoutComplete(overrides?: CallOverrides): Promise<boolean>;

    minerRedeem(overrides?: CallOverrides): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<string>;

    paymentToken(overrides?: CallOverrides): Promise<string>;

    reservedPrice(overrides?: CallOverrides): Promise<BigNumber>;

    seller(overrides?: CallOverrides): Promise<string>;

    sellerRedeemDefault(overrides?: CallOverrides): Promise<BigNumber>;

    silicaAccount(overrides?: CallOverrides): Promise<string>;

    startDay(overrides?: CallOverrides): Promise<number>;

    status(overrides?: CallOverrides): Promise<number>;

    symbol(overrides?: CallOverrides): Promise<string>;

    totalPayment(overrides?: CallOverrides): Promise<BigNumber>;

    totalSold(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transfer(
      to: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    transferFrom(
      from: string,
      to: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    tryToCompleteContract(
      day: BigNumberish,
      remainingExcess: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber]>;

    tryToExpireContract(
      day: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber]>;

    tryToStartContract(
      day: BigNumberish,
      _networkHashrate: BigNumberish,
      _networkReward: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber]>;
  };

  filters: {
    "Approval(address,address,uint256)"(
      owner?: string | null,
      spender?: string | null,
      value?: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { owner: string; spender: string; value: BigNumber }
    >;

    Approval(
      owner?: string | null,
      spender?: string | null,
      value?: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { owner: string; spender: string; value: BigNumber }
    >;

    "BidConfirmed(address,uint256,uint256,uint256)"(
      buyer?: string | null,
      purchaseAmount?: null,
      mintedTokens?: null,
      timestamp?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber, BigNumber],
      {
        buyer: string;
        purchaseAmount: BigNumber;
        mintedTokens: BigNumber;
        timestamp: BigNumber;
      }
    >;

    BidConfirmed(
      buyer?: string | null,
      purchaseAmount?: null,
      mintedTokens?: null,
      timestamp?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber, BigNumber],
      {
        buyer: string;
        purchaseAmount: BigNumber;
        mintedTokens: BigNumber;
        timestamp: BigNumber;
      }
    >;

    "BuyerDefault(address,uint256,uint256)"(
      buyer?: string | null,
      paymentAmount?: null,
      rewardAmount?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { buyer: string; paymentAmount: BigNumber; rewardAmount: BigNumber }
    >;

    BuyerDefault(
      buyer?: string | null,
      paymentAmount?: null,
      rewardAmount?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { buyer: string; paymentAmount: BigNumber; rewardAmount: BigNumber }
    >;

    "BuyerRedeem(address,uint256,uint256)"(
      buyer?: string | null,
      rewardAmount?: null,
      tokensBurned?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { buyer: string; rewardAmount: BigNumber; tokensBurned: BigNumber }
    >;

    BuyerRedeem(
      buyer?: string | null,
      rewardAmount?: null,
      tokensBurned?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { buyer: string; rewardAmount: BigNumber; tokensBurned: BigNumber }
    >;

    "Initialized(uint8)"(
      version?: null
    ): TypedEventFilter<[number], { version: number }>;

    Initialized(
      version?: null
    ): TypedEventFilter<[number], { version: number }>;

    "SellerDefault(address,uint256)"(
      seller?: string | null,
      paymentAmount?: null
    ): TypedEventFilter<
      [string, BigNumber],
      { seller: string; paymentAmount: BigNumber }
    >;

    SellerDefault(
      seller?: string | null,
      paymentAmount?: null
    ): TypedEventFilter<
      [string, BigNumber],
      { seller: string; paymentAmount: BigNumber }
    >;

    "SellerRedeem(address,uint256)"(
      seller?: string | null,
      paymentAmount?: null
    ): TypedEventFilter<
      [string, BigNumber],
      { seller: string; paymentAmount: BigNumber }
    >;

    SellerRedeem(
      seller?: string | null,
      paymentAmount?: null
    ): TypedEventFilter<
      [string, BigNumber],
      { seller: string; paymentAmount: BigNumber }
    >;

    "StatusChange(uint256)"(
      newStatus?: null
    ): TypedEventFilter<[BigNumber], { newStatus: BigNumber }>;

    StatusChange(
      newStatus?: null
    ): TypedEventFilter<[BigNumber], { newStatus: BigNumber }>;

    "Transfer(address,address,uint256)"(
      from?: string | null,
      to?: string | null,
      value?: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { from: string; to: string; value: BigNumber }
    >;

    Transfer(
      from?: string | null,
      to?: string | null,
      value?: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { from: string; to: string; value: BigNumber }
    >;
  };

  estimateGas: {
    allowance(
      owner: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    amountDueAtContractEnd(overrides?: CallOverrides): Promise<BigNumber>;

    amountLocked(overrides?: CallOverrides): Promise<BigNumber>;

    amountOwedNextUpdate(overrides?: CallOverrides): Promise<BigNumber>;

    approve(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    buyerRedeem(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    buyerRedeemDefault(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    calculateHaircut(
      day: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    contractPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    decimals(overrides?: CallOverrides): Promise<BigNumber>;

    decreaseAllowance(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    defaultContract(
      day: BigNumberish,
      _networkHashrate: BigNumberish,
      _networkReward: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    deployTime(overrides?: CallOverrides): Promise<BigNumber>;

    deposit(
      purchaseAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    endDay(overrides?: CallOverrides): Promise<BigNumber>;

    fulfillUpdate(
      _networkHashrate: BigNumberish,
      _networkReward: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    hashrate(overrides?: CallOverrides): Promise<BigNumber>;

    increaseAllowance(
      spender: string,
      addedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    initialize(
      _paymentToken: string,
      _hashrate: BigNumberish,
      _contractPeriod: BigNumberish,
      _reservedPrice: BigNumberish,
      _seller: string,
      _amountLockedOnCreate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    isMinerDefaultPayoutComplete(overrides?: CallOverrides): Promise<BigNumber>;

    minerRedeem(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    name(overrides?: CallOverrides): Promise<BigNumber>;

    paymentToken(overrides?: CallOverrides): Promise<BigNumber>;

    reservedPrice(overrides?: CallOverrides): Promise<BigNumber>;

    seller(overrides?: CallOverrides): Promise<BigNumber>;

    sellerRedeemDefault(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    silicaAccount(overrides?: CallOverrides): Promise<BigNumber>;

    startDay(overrides?: CallOverrides): Promise<BigNumber>;

    status(overrides?: CallOverrides): Promise<BigNumber>;

    symbol(overrides?: CallOverrides): Promise<BigNumber>;

    totalPayment(overrides?: CallOverrides): Promise<BigNumber>;

    totalSold(overrides?: CallOverrides): Promise<BigNumber>;

    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

    transfer(
      to: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    transferFrom(
      from: string,
      to: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    tryToCompleteContract(
      day: BigNumberish,
      remainingExcess: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    tryToExpireContract(
      day: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    tryToStartContract(
      day: BigNumberish,
      _networkHashrate: BigNumberish,
      _networkReward: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    allowance(
      owner: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    amountDueAtContractEnd(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    amountLocked(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    amountOwedNextUpdate(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    approve(
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    balanceOf(
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    buyerRedeem(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    buyerRedeemDefault(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    calculateHaircut(
      day: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    contractPeriod(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    decreaseAllowance(
      spender: string,
      subtractedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    defaultContract(
      day: BigNumberish,
      _networkHashrate: BigNumberish,
      _networkReward: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    deployTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deposit(
      purchaseAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    endDay(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    fulfillUpdate(
      _networkHashrate: BigNumberish,
      _networkReward: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    hashrate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    increaseAllowance(
      spender: string,
      addedValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    initialize(
      _paymentToken: string,
      _hashrate: BigNumberish,
      _contractPeriod: BigNumberish,
      _reservedPrice: BigNumberish,
      _seller: string,
      _amountLockedOnCreate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    isMinerDefaultPayoutComplete(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    minerRedeem(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    paymentToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    reservedPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    seller(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    sellerRedeemDefault(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    silicaAccount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    startDay(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    status(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalPayment(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSold(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transfer(
      to: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    transferFrom(
      from: string,
      to: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    tryToCompleteContract(
      day: BigNumberish,
      remainingExcess: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    tryToExpireContract(
      day: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    tryToStartContract(
      day: BigNumberish,
      _networkHashrate: BigNumberish,
      _networkReward: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
